"use strict";(globalThis.webpackChunkmy_tutorial=globalThis.webpackChunkmy_tutorial||[]).push([[2185],{654:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/4-6-1-5bb86bb96aede00078baf256657d8843.png"},2133:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/4-6-2-03cdca668a1517ffb4ccb49aca419d6f.png"},3619:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/4-6-4-506bdf21b03e14c3ffa6a6362ffa0e2d.png"},6220:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/4-6-3-eb2cb1c6b929e02158c34d038cab4bb3.png"},7170:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"mcut-tutorial/week-4/4-6","title":"4-6 Introduction to GPIOs","description":"This chapter demonstrates how to test and develop programs to control the GPIO hardware pins on the Renesas RZ/G2L platform within a Linux environment. It covers using Linux Sysfs to manage GPIOs via file-based read/write commands.","source":"@site/docs/mcut-tutorial/week-4/4-6.md","sourceDirName":"mcut-tutorial/week-4","slug":"/mcut-tutorial/week-4/4-6","permalink":"/zb/docs/mcut-tutorial/week-4/4-6","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/mcut-tutorial/week-4/4-6.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"4-6 Introduction to GPIOs","sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"4-5 Build Executables","permalink":"/zb/docs/mcut-tutorial/week-4/4-5"},"next":{"title":"extra","permalink":"/zb/docs/mcut-tutorial/week-4/4.7"}}');var i=t(4848),r=t(8453);const o={title:"4-6 Introduction to GPIOs",sidebar_position:6},a="4-6 Introduction to GPIOs",c={},d=[{value:"Linux Sysfs",id:"linux-sysfs",level:2},{value:"Accessing GPIO Pins",id:"accessing-gpio-pins",level:2},{value:"Controlling GPIO Pins",id:"controlling-gpio-pins",level:2},{value:"Hardware Testing Through PMOD Interface",id:"hardware-testing-through-pmod-interface",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",hr:"hr",img:"img",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"4-6-introduction-to-gpios",children:"4-6 Introduction to GPIOs"})}),"\n",(0,i.jsx)(n.p,{children:"This chapter demonstrates how to test and develop programs to control the GPIO hardware pins on the Renesas RZ/G2L platform within a Linux environment. It covers using Linux Sysfs to manage GPIOs via file-based read/write commands."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"linux-sysfs",children:"Linux Sysfs"}),"\n",(0,i.jsx)(n.p,{children:"Sysfs is a pseudo-filesystem in Linux that provides a way to interact with kernel subsystems, hardware devices, and drivers via virtual files."}),"\n",(0,i.jsx)(n.p,{children:"To read a file, use the following command:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cat filename\n"})}),"\n",(0,i.jsx)(n.p,{children:"To write to a file, use:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"echo xxx > filename\n"})}),"\n",(0,i.jsx)(n.h2,{id:"accessing-gpio-pins",children:"Accessing GPIO Pins"}),"\n",(0,i.jsxs)(n.p,{children:["To access GPIO privileges on the RZ/G2L broad, navigate to ",(0,i.jsx)(n.code,{children:"/sys/class/gpio/"})," and export the desired GPIO pin ID:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"echo gpio-pin-id > export\n"})}),"\n",(0,i.jsxs)(n.admonition,{title:"Renesas GPIO Pin IDs",type:"tip",children:[(0,i.jsxs)(n.p,{children:["GPIO Pin IDs are calculated based on the port and pin as outlined in page 8 of ",(0,i.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:t(9180).A+"",children:"Renesas GPIO documentation"}),". For RZ/G2L, the formula is shown below:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"GPIO ID = (Port Number * 8) + Pin Number + 120\n"})}),(0,i.jsxs)(n.p,{children:["For ",(0,i.jsxs)(n.strong,{children:["P42_4 (",(0,i.jsx)(n.em,{children:"Port 42, Pin 4"}),")"]}),":"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"GPIO ID = (42 * 8) + 4 + 120 = 460\n"})})]}),"\n",(0,i.jsxs)(n.p,{children:["After exporting the pins, a directory named after your pin (e.g. P42_4) will be created under the ",(0,i.jsx)(n.code,{children:"/sys/class/gpio/"})," directory. Enter into the directory and use the command ",(0,i.jsx)(n.code,{children:"ls"})," to list all the files."]}),"\n",(0,i.jsx)(n.p,{children:"The output will be:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"active_low  device  direction  edge  power  subsystem  uevent  value\n"})}),"\n",(0,i.jsx)(n.h2,{id:"controlling-gpio-pins",children:"Controlling GPIO Pins"}),"\n",(0,i.jsxs)(n.p,{children:["To control GPIO pins, please ensure that you are in the ",(0,i.jsx)(n.code,{children:"sys/class/gpio"})," directory."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Setting Pin Direction"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'echo "out" > direction\necho "in" > direction\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Writing Values To Pin"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"echo 1 > value\necho 0 > value\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Reading The Pin State"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cat value\n"})}),"\n",(0,i.jsx)(n.h2,{id:"hardware-testing-through-pmod-interface",children:"Hardware Testing Through PMOD Interface"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"PMOD (Peripheral Module)"})," interface is a standardized connector used to interface peripheral modules with a host device, such as development boards, microcontrollers, or FPGAs. Developed by Digilent, PMOD connectors typically use a 6-pin or 12-pin header configuration, carrying signals such as power, ground, and data lines for SPI, I2C, UART, or GPIO communication. Designed for simplicity and flexibility, PMOD modules offer plug-and-play compatibility, enabling developers to easily add functionality like sensors, displays, and communication modules to projects without the need for complex wiring or additional circuitry."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://digilent.com/reference/pmod/pmodbtn/start",children:"PMOD Button"})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"alt text",src:t(654).A+"",width:"150",height:"82"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://digilent.com/reference/pmod/pmodswt/start",children:"PMOD Switch"})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"alt text",src:t(2133).A+"",width:"150",height:"150"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://digilent.com/reference/pmod/pmodled/start",children:"PMOD LED"})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"alt text",src:t(6220).A+"",width:"150",height:"150"})}),"\n",(0,i.jsx)(n.p,{children:"Clone the GitHub repository below and build it in Qt Creator using the RZ/G2L kit."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/yourskc/q563_rzgpio.git\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To match the configuration of the software program, please plug in the PMOD switch and LED according to the picture shown below. The PMOD switch should be connected to the 6 lower pins of ",(0,i.jsx)(n.code,{children:"PMOD1"}),", and the PMOD LED should be connected to the 6 lower pins of ",(0,i.jsx)(n.code,{children:"PMOD"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"plugitin",src:t(3619).A+"",width:"2560",height:"1940"})}),"\n",(0,i.jsx)(n.p,{children:"Transfer the executable to RZ/G2L and run it. Try out the program and observe the output."}),"\n",(0,i.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},9180:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/files/R01US0405EJ0111_GPIO_UME_v1.11-be60a1b47a9c51e43da10df045dfb584.pdf"}}]);